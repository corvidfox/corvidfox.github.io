#' @file stylers.R
#' @title Theme and Plot Styling Utilities
#'
#' Collection of reusable visual styling functions for Shiny apps, including:
#' - Bootstrap 5 themes for light and dark modes using `bslib`
#' - Reactive-friendly plot styling utilities for `ggplot2` and `plotly`
#'
#' All plotting functions assume a `styles` list, typically generated by
#' \code{\link{generate_styles}}.

#' Light Mode Theme
#'
#' Defines a `bslib` Bootstrap 5 intended for light mode styling in the UI.
#'
#' @format A `bs_theme` object.
#' @seealso \code{\link[bslib]{bs_theme}}
theme_light <- bslib::bs_theme(
  version = 5,
  bootswatch = "flatly",
  base_font = font_google("Inter")
)

#' Dark Mode Theme
#'
#' Defines a `bslib` Bootstrap 5 intended for dark mode styling in the UI.
#'
#' @format A `bs_theme` object.
#' @seealso \code{\link[bslib]{bs_theme}}
theme_dark <- bs_theme(
  version = 5,
  bootswatch = "darkly",
  base_font = font_google("Inter")
)

#' Generate Custom CSS for Thematic Styling and Transitions
#'
#' Returns a string of CSS rules that define the appearance and responsive
#' transitions of key UI elements (e.g., cards, data tables, buttons, tabs)
#' based on the currently active Bootstrap theme. It uses Bootstrap 5 variable
#' names (e.g., `--bs-primary`, `--bs-body-bg`) so the styles update
#' automatically with theme changes.
#'
#' This function is intended to be used inside `renderUI()` and injected into
#' the UI via `tags$style()` or `uiOutput()`, ensuring dynamic styling that
#' adapts to light/dark modes or custom themes.
#'
#' @param theme A `bslib::bs_theme` object (e.g., `theme_light` or `theme_dark`)
#' from which Bootstrap variable values can be extracted.
#'
#' @return A character string containing CSS.
#' 
#' @examples
#' theme <- if (input$theme_switcher == "dark") theme_dark else theme_light
#' tags$style(HTML(generate_css(theme)))
generate_css <- function(theme) {
  theme_vars <- bslib::bs_get_variables(theme, c(
    "primary", "secondary-bg", "body-bg", "body-color",
    "border-color", "primary-bg-subtle"
  ))
  
  glue::glue("
    /* Sticky Title Bar */
    .sticky-header {{
      position: sticky;
      top: 0;
      z-index: 1000;
      background-color: {theme_vars[['body-bg']]};
      border-bottom: 1px solid {theme_vars[['border-color']]};
      transition: background-color 0.4s ease, color 0.4s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }}
    
    /* Styler for transition between themes */  
    html, body {{
      transition: background-color 0.5s ease, color 0.5s ease;
    }}  

    .theme-transition, 
    .theme-transition * {{
      transition: 
        background-color 0.4s ease,
        color 0.4s ease,
        border-color 0.4s ease,
        box-shadow 0.4s ease;
    }}

    /* Style Nav Tabs */
    .nav-tabs .nav-link {{
      color: {theme_vars[['body-color']]};
      background-color: {theme_vars[['body-bg']]};
      border: 1px solid {theme_vars[['border-color']]};
      margin-right: 4px;
    }}

    .nav-tabs .nav-link.active {{
      background-color: {theme_vars[['primary']]};
      color: {theme_vars[['body-bg']]};
      border-color: {theme_vars[['primary']]};
    }}

    /* Center & Compact Data Table Pagination */
    .dataTables_wrapper .dataTables_paginate {{
      display: flex !important;
      justify-content: center !important;
      width: 100% !important;
    }}

    .dataTables_wrapper .dataTables_paginate .pagination {{
      margin: 0 auto !important;
    }}

    .dataTables_wrapper .dataTables_paginate .paginate_button {{
      background-color: {theme_vars[['secondary-bg']]} !important;
      color: {theme_vars[['body-color']]} !important;
      border: 1px solid {theme_vars[['border-color']]} !important;
    }}

    .dataTables_wrapper .dataTables_paginate .paginate_button.current {{
      background-color: {theme_vars[['primary']]} !important;
      color: {theme_vars[['body-bg']]} !important;
    }}

    /* Download Button Styling */
    .download-btn {{
      background-color: {theme_vars[['primary']]} !important;
      color: {theme_vars[['body-bg']]} !important;
      border: none !important;
      padding: 8px 16px !important;
      font-weight: bold !important;
      border-radius: 4px !important;
      font-size: 0.95rem;
      transition: background-color 0.3s ease;
    }}

    .download-btn:hover {{
      background-color: {theme_vars[['primary-bg-subtle']]} !important;
      color: {theme_vars[['body-color']]} !important;
    }}

    /* Responsive KPI Boxes */
    .bslib-column-wrap > * {{
      flex: 1 1 100%;
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }}

    .bslib-card {{
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }}

    .bslib-card:hover {{
      box-shadow: 0 2px 12px rgba(0,0,0,0.2);
      transition: box-shadow 0.3s ease-in-out;
    }}
  ")
}

#' Generate Plot & UI Style Parameters from Active Theme
#'
#' Returns a named list of styling values (colors, sizes, backgrounds)
#' based on the current theme and switch toggle state.
#'
#' @param theme_mode A character string, either `"light"` or `"dark"`.
#'
#' @return A named list of values to be passed into plot & UI styling functions.
#' @examples
#' styles <- generate_styles("light")
generate_styles <- function(theme_mode = "light") {
  current_theme <- if (identical(theme_mode, "dark")) {
    theme_dark
  } else {
    theme_light
  }
  theme_colors <- bslib::bs_get_variables(
    current_theme,
    varnames = c(
      "primary", "secondary", "body-color", "body-bg", "secondary-bg"
    )
  )
  
  list(
    # Basic Colors & Fonts
    line_color = theme_colors[["primary"]],
    point_color = theme_colors[["secondary"]],
    text_color = theme_colors[["body-color"]],
    font_size = 14,
    line_size = 0.75,
    point_size = 1,
    
    # Backgrounds
    ggplot_bg = "transparent",
    plotly_bg = "rgba(0,0,0,0)",
    plotly_hover_bg = theme_colors[["body-bg"]],
    
    # Plotly Geo
    geo_border_color = theme_colors[["secondary"]],
    geo_frame_color = theme_colors[["body-color"]],
    geo_country_fill = theme_colors[["secondary"]],
    geo_border_width = 0.5,
    
    # Color Scale
    fill_palette = list(
      colorscale = "Viridis",
      reversescale = TRUE,
      colorbar = list(
        tickfont = list(color = theme_colors[["body-color"]]),
        titlefont = list(color = theme_colors[["body-color"]])
      )
    ),
    
    # KPI Card Specific
    kpi_bg = theme_colors[["secondary-bg"]],
    secondary_color = theme_colors[["secondary"]]
  )
}


#' Style ggplot with Custom Theme
#'
#' Applies color and text styling to a `ggplot2` object using the provided
#' styles.
#'
#' @param ggplot_plot A `ggplot` object to be styled.
#' @param styles A named list of style values, such as `font_size`, 
#'   `ggplot_bg`, and `text_color`.
#'
#' @return A styled `ggplot` object.
#' @examples
#' styles <- list(
#'   font_size = 12, 
#'   ggplot_bg = "#ffffff", 
#'   text_color = "#000000"
#'   )
#' plot <- ggplot2::ggplot(data.frame(x=1:5, y=1:5), aes(x, y)) + geom_point()
#' plot |> style_ggplot2(styles)
style_ggplot2 <- function(ggplot_plot, styles) {
  s <- styles
  
  # Apply Styles
  ggplot_plot +
    ggplot2::theme_minimal(base_size = s$font_size) +
    ggplot2::theme(
      plot.background = ggplot2::element_rect(fill = s$ggplot_bg, color = NA),
      panel.background = ggplot2::element_rect(fill = s$ggplot_bg, color = NA),
      text = ggplot2::element_text(color = s$text_color),
      legend.background = ggplot2::element_rect(fill = s$ggplot_bg, color = NA),
      axis.text = ggplot2::element_text(color = s$text_color),
      axis.title = ggplot2::element_text(color = s$text_color),
      legend.text = ggplot2::element_text(color = s$text_color),
      legend.title = ggplot2::element_text(color = s$text_color),
      title = ggplot2::element_text(color = s$text_color)
    )
}

#' Style Plotly Plot
#'
#' Applies layout theming, font styling, background colors, and geo-specific 
#' layout to a Plotly chart using a provided `styles` list. Supports both 
#' generic plots and choropleth-style `geo` maps, ensuring consistent 
#' appearance across light/dark modes.
#'
#' If the plot type is `"geo"`, additional geographic layout parameters are 
#' applied, including `natural earth` projection, background fill, 
#' frame color, land fill, and an annotation indicating countries with 
#' missing data.
#'
#' @param plotly_plot A Plotly object created using `plotly::plot_ly()` or 
#'   similar.
#' @param styles A named list of theme-aware style values (e.g., colors, font 
#'   sizes) typically generated by a function like `generate_styles()`. Must 
#'   include background colors, text colors, geo-specific colors, and font size.
#' @param type A character string indicating the plot type. Use `"geo"` for 
#'   choropleth-style maps or `"default"` for generic charts. Additional plot 
#'   types may be supported in the future.
#' @param axes_labs A named list of axes label text, since plotly likes to 
#'   forget what you named your axes when converting from ggplot sometimes. 
#'
#' @return A `plotly` object with theme-consistent styling applied.
#'
#' @examples
#' styles <- generate_styles(theme_mode = "dark")
#' p <- plotly::plot_ly(
#'   data = df, x = ~x, y = ~y, type = "scatter", mode = "lines"
#'   )
#' styled_plot <- style_plotly(p, styles, type = "default")
#'
#' @seealso \code{\link[plotly]{layout}}, \code{\link[plotly]{plot_ly}}, 
#'   \code{\link{generate_styles}}
#' @export
style_plotly <- function(
    plotly_plot, styles, type = "default", axes_labs = NULL
) {
  s <- styles
  is_geo <- type == "geo"
  
  layout_opts <- list(
    paper_bgcolor = s$plotly_bg,
    plot_bgcolor = s$plotly_bg,
    font = list(color = s$text_color, size = s$font_size),
    legend = list(bgcolor = s$plotly_bg, font = list(color = s$text_color)),
    hoverlabel = list(
      bgcolor = s$plotly_hover_bg,
      font = list(color = s$text_color),
      bordercolor = s$text_color,
      align = "left"
    ),
    margin = list(t = 40)
  )

  if (is_geo) {
    layout_opts$geo <- list(
      showframe = TRUE,
      showcoastlines = TRUE,
      showland = TRUE,
      projection = list(type = "natural earth"),
      bgcolor = s$plotly_bg,
      framecolor = s$geo_frame_color,
      landcolor = s$geo_country_fill
    )
    
    layout_opts$annotations = list(
      list(
        text = "<b>No Data Available for Location<b>",
        x = 0.01,
        y = -0.1,
        xref = "paper",
        yref = "paper",
        showarrow = FALSE,
        font = list(
          size = s$font_size - 1,
          color = s$text_color
        ),
        bgcolor = s$geo_country_fill,
        bordercolor = s$geo_frame_color,
        borderwidth = 1,
        opacity = 0.8
      )
    )
    
  } else {
    layout_opts$xaxis <- list(
      tickfont = list(color = s$text_color),
      titlefont = list(color = s$text_color)
    )
    layout_opts$yaxis <- list(
      tickfont = list(color = s$text_color),
      titlefont = list(color = s$text_color)
    )
    layout_opts$hovermode <- "x unified"
  }
  
  # Optional manual override of axes and legend labels
  if (!is.null(axes_labs)) {
    if (!is.null(axes_labs$x)) {
      layout_opts$xaxis$title <- list(
        text = axes_labs$x, 
        font = list(color = s$text_color)
        )
    }
    if (!is.null(axes_labs$y)) {
      layout_opts$yaxis$title <- list(
        text = axes_labs$y, 
        font = list(color = s$text_color)
        )
    }
    if (!is.null(axes_labs$legend)) {
      layout_opts$legend$title <- list(
        text = axes_labs$legend, 
        font = list(color = s$text_color)
        )
    }
  }
  
  
  do.call(plotly::layout, c(list(p = plotly_plot), layout_opts))
  
}

#' Convert ISO Alpha-3 Country Code to Flag Emoji (with blank fallback)
#'
#' Converts ISO 3166-1 alpha-3 country codes (e.g., "USA") into corresponding
#' Unicode flag emojis. If a code is invalid or unrecognized, returns a blank 
#' string.
#'
#' @param iso3 A character vector of ISO alpha-3 country codes.
#'
#' @return A character vector of flag emojis or blank strings.
#'
#' @examples
#' iso3_to_flag("USA")          # "🇺🇸"
#' iso3_to_flag("XXX")          # "" (fallback)
#' iso3_to_flag(c("USA", "XXX"))  # c("🇺🇸", "")
#'
#' @export
iso3_to_flag <- function(iso3) {
  iso2 <- countrycode::countrycode(
    iso3, origin = "iso3c", destination = "iso2c"
  )
  iso2 <- toupper(iso2)
  
  valid <- grepl("^[A-Z]{2}$", iso2)
  
  flagify <- function(code) {
    paste0(
      intToUtf8(127397 + utf8ToInt(substr(code, 1, 1))),
      intToUtf8(127397 + utf8ToInt(substr(code, 2, 2)))
    )
  }
  
  flags <- ifelse(valid, vapply(iso2, flagify, character(1)), "")
  return(flags)
}
